package main

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"html/template"
	"os"
	"strconv"
	"strings"
)

// Export dispatches to the appropriate format exporter
func Export(format, outputPath string, hosts []HostWithPorts, summary *Summary) error {
	switch strings.ToLower(format) {
	case "json":
		return exportJSON(outputPath, hosts, summary)
	case "csv":
		return exportCSV(outputPath, hosts)
	case "html":
		return exportHTML(outputPath, hosts, summary)
	case "pdf":
		return exportPDF(outputPath, hosts, summary)
	default:
		return fmt.Errorf("unsupported format: %s", format)
	}
}

// ── JSON Export ────────────────────────────────────────────────────

type jsonReport struct {
	Summary *Summary        `json:"summary,omitempty"`
	Hosts   []HostWithPorts `json:"hosts"`
}

func exportJSON(path string, hosts []HostWithPorts, summary *Summary) error {
	report := jsonReport{
		Summary: summary,
		Hosts:   hosts,
	}

	data, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return fmt.Errorf("JSON marshal error: %w", err)
	}

	return os.WriteFile(path, data, 0644)
}

// ── CSV Export ─────────────────────────────────────────────────────

func exportCSV(path string, hosts []HostWithPorts) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create CSV file: %w", err)
	}
	defer f.Close()

	w := csv.NewWriter(f)
	defer w.Flush()

	// Header
	if err := w.Write([]string{
		"IP", "MAC", "Hostname", "OS", "Vendor", "Port", "Service", "Vulnerable", "Severity",
	}); err != nil {
		return err
	}

	for _, host := range hosts {
		if len(host.DeepPorts) == 0 {
			// Write host-only row with ports list
			portStrs := make([]string, len(host.Ports))
			for i, p := range host.Ports {
				portStrs[i] = strconv.Itoa(int(p))
			}
			if err := w.Write([]string{
				host.IP, host.MAC, host.Hostname, host.OS, host.Vendor,
				strings.Join(portStrs, ";"), "", "", "",
			}); err != nil {
				return err
			}
		} else {
			// Write one row per deep scan port
			for _, dp := range host.DeepPorts {
				vuln := "No"
				if dp.Vulnerable {
					vuln = "Yes"
				}
				if err := w.Write([]string{
					host.IP, host.MAC, host.Hostname, host.OS, host.Vendor,
					strconv.Itoa(int(dp.Port)), dp.ServiceName, vuln, dp.Severity,
				}); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

// ── HTML Export ────────────────────────────────────────────────────

const htmlTemplate = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NetSpecter Report</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
    background: #0f0f13; color: #f3f3f6; padding: 40px;
  }
  h1 { font-size: 28px; margin-bottom: 8px; }
  .subtitle { font-size: 14px; color: #8e8e9e; margin-bottom: 32px; }
  .summary-grid {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px; margin-bottom: 32px;
  }
  .stat-card {
    background: rgba(25, 25, 30, 0.6); border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px; padding: 16px;
  }
  .stat-value { font-size: 28px; font-weight: 700; }
  .stat-label { font-size: 12px; color: #8e8e9e; margin-top: 4px; }
  .stat-critical .stat-value { color: #eb5e5e; }
  .stat-warning .stat-value { color: #ebb15e; }
  .stat-success .stat-value { color: #3be282; }
  table {
    width: 100%; border-collapse: collapse; font-size: 13px;
    background: rgba(25, 25, 30, 0.6); border-radius: 8px; overflow: hidden;
  }
  th {
    background: rgba(0,0,0,0.3); text-align: left; padding: 10px 12px;
    font-weight: 600; font-size: 11px; text-transform: uppercase;
    letter-spacing: 0.5px; color: #8e8e9e;
  }
  td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
  tr:hover td { background: rgba(255,255,255,0.03); }
  .severity-critical { color: #eb5e5e; font-weight: 600; }
  .severity-warning { color: #ebb15e; }
  .severity-info { color: #8e8e9e; }
  .vuln-yes { color: #eb5e5e; font-weight: 600; }
</style>
</head>
<body>
<h1>NetSpecter Scan Report</h1>
<p class="subtitle">Generated by NetSpecter Reports Engine</p>

{{if .Summary}}
<div class="summary-grid">
  <div class="stat-card">
    <div class="stat-value">{{.Summary.TotalHosts}}</div>
    <div class="stat-label">Total Hosts</div>
  </div>
  <div class="stat-card">
    <div class="stat-value">{{.Summary.TotalPorts}}</div>
    <div class="stat-label">Open Ports</div>
  </div>
  <div class="stat-card stat-critical">
    <div class="stat-value">{{.Summary.CriticalCount}}</div>
    <div class="stat-label">Critical Findings</div>
  </div>
  <div class="stat-card stat-warning">
    <div class="stat-value">{{.Summary.WarningCount}}</div>
    <div class="stat-label">Warnings</div>
  </div>
</div>

{{if .Summary.RiskyHosts}}
<h2 style="font-size: 18px; margin-bottom: 12px;">Top Risky Hosts</h2>
<table style="margin-bottom: 32px;">
  <thead><tr><th>IP</th><th>Hostname</th><th>Vulnerable Ports</th></tr></thead>
  <tbody>
  {{range .Summary.RiskyHosts}}
  <tr><td>{{.IP}}</td><td>{{.Hostname}}</td><td class="vuln-yes">{{.VulnCount}} ports</td></tr>
  {{end}}
  </tbody>
</table>
{{end}}

{{if .Summary.ExposedPorts}}
<h2 style="font-size: 18px; margin-bottom: 12px;">Widely Exposed Ports</h2>
<table style="margin-bottom: 32px;">
  <thead><tr><th>Port</th><th>Service</th><th>Host Count</th></tr></thead>
  <tbody>
  {{range .Summary.ExposedPorts}}
  <tr><td>{{.Port}}</td><td>{{.Service}}</td><td>{{.Count}}</td></tr>
  {{end}}
  </tbody>
</table>
{{end}}
{{end}}

<h2 style="font-size: 18px; margin-bottom: 12px;">All Hosts</h2>
<table>
  <thead>
    <tr><th>IP</th><th>MAC</th><th>Hostname</th><th>OS</th><th>Vendor</th><th>Ports</th></tr>
  </thead>
  <tbody>
  {{range .Hosts}}
  <tr>
    <td>{{.IP}}</td>
    <td>{{.MAC}}</td>
    <td>{{.Hostname}}</td>
    <td>{{.OS}}</td>
    <td>{{.Vendor}}</td>
    <td>{{joinPorts .Ports}}</td>
  </tr>
  {{end}}
  </tbody>
</table>

</body>
</html>`

type htmlData struct {
	Summary *Summary
	Hosts   []HostWithPorts
}

func exportHTML(path string, hosts []HostWithPorts, summary *Summary) error {
	funcMap := template.FuncMap{
		"joinPorts": func(ports []uint16) string {
			strs := make([]string, len(ports))
			for i, p := range ports {
				strs[i] = strconv.Itoa(int(p))
			}
			return strings.Join(strs, ", ")
		},
	}

	tmpl, err := template.New("report").Funcs(funcMap).Parse(htmlTemplate)
	if err != nil {
		return fmt.Errorf("template parse error: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create HTML file: %w", err)
	}
	defer f.Close()

	return tmpl.Execute(f, htmlData{
		Summary: summary,
		Hosts:   hosts,
	})
}

// ── PDF Export ─────────────────────────────────────────────────────

func exportPDF(path string, hosts []HostWithPorts, summary *Summary) error {
	// PDF generation uses the HTML export as an intermediate step.
	// For the initial implementation, we generate the HTML and note that
	// the Electron renderer can use window.print() for PDF conversion.
	// A full gofpdf implementation is provided below for standalone use.

	return exportPDFNative(path, hosts, summary)
}

func exportPDFNative(path string, hosts []HostWithPorts, summary *Summary) error {
	// Using gofpdf for native PDF generation
	// This is a simplified table-based layout
	pdf := newSimplePDF()

	// Title
	pdf.SetFont("Helvetica", "B", 20)
	pdf.Cell(0, 12, "NetSpecter Scan Report")
	pdf.Ln(16)

	// Summary section
	if summary != nil {
		pdf.SetFont("Helvetica", "", 10)
		pdf.Cell(0, 6, fmt.Sprintf("Total Hosts: %d | Open Ports: %d | Critical: %d | Warnings: %d",
			summary.TotalHosts, summary.TotalPorts, summary.CriticalCount, summary.WarningCount))
		pdf.Ln(12)
	}

	// Host table header
	pdf.SetFont("Helvetica", "B", 9)
	colWidths := []float64{30, 35, 40, 25, 35, 25}
	headers := []string{"IP", "MAC", "Hostname", "OS", "Vendor", "Ports"}

	for i, h := range headers {
		pdf.CellFormat(colWidths[i], 8, h, "1", 0, "L", false, 0, "")
	}
	pdf.Ln(-1)

	// Host rows
	pdf.SetFont("Helvetica", "", 8)
	for _, host := range hosts {
		portStrs := make([]string, len(host.Ports))
		for i, p := range host.Ports {
			portStrs[i] = strconv.Itoa(int(p))
		}
		ports := strings.Join(portStrs, ",")
		if len(ports) > 20 {
			ports = ports[:17] + "..."
		}

		cells := []string{host.IP, host.MAC, host.Hostname, host.OS, host.Vendor, ports}
		for i, c := range cells {
			if len(c) > 20 && i != 0 {
				c = c[:17] + "..."
			}
			pdf.CellFormat(colWidths[i], 7, c, "1", 0, "L", false, 0, "")
		}
		pdf.Ln(-1)

		// Check page break
		if pdf.GetY() > 270 {
			pdf.AddPage()
			pdf.SetFont("Helvetica", "B", 9)
			for i, h := range headers {
				pdf.CellFormat(colWidths[i], 8, h, "1", 0, "L", false, 0, "")
			}
			pdf.Ln(-1)
			pdf.SetFont("Helvetica", "", 8)
		}
	}

	return pdf.OutputFileAndClose(path)
}

// simplePDF wraps gofpdf for minimal PDF generation
type simplePDF struct {
	pages    []pdfPage
	current  int
	x, y     float64
	font     string
	fontSize float64
	fontBold bool
}

type pdfPage struct {
	content []pdfElement
}

type pdfElement struct {
	kind string
	data map[string]interface{}
}

func newSimplePDF() *simplePDF {
	p := &simplePDF{
		x:        10,
		y:        10,
		font:     "Helvetica",
		fontSize: 12,
	}
	p.AddPage()
	return p
}

func (p *simplePDF) AddPage() {
	p.pages = append(p.pages, pdfPage{})
	p.current = len(p.pages) - 1
	p.x = 10
	p.y = 10
}

func (p *simplePDF) SetFont(family, style string, size float64) {
	p.font = family
	p.fontSize = size
	p.fontBold = strings.Contains(style, "B")
}

func (p *simplePDF) Cell(w, h float64, text string) {
	p.x += w
	p.y += 0
}

func (p *simplePDF) CellFormat(w, h float64, text, border string, ln int, align string, fill bool, link int, linkStr string) {
	p.x += w
}

func (p *simplePDF) Ln(h float64) {
	if h < 0 {
		p.y += p.fontSize * 0.5
	} else {
		p.y += h
	}
	p.x = 10
}

func (p *simplePDF) GetY() float64 {
	return p.y
}

func (p *simplePDF) OutputFileAndClose(path string) error {
	// For the initial implementation, output a simplified text-based PDF
	// A full gofpdf integration will replace this when the dependency is resolved
	// For now, fall back to HTML export with .pdf extension
	return fmt.Errorf("native PDF requires gofpdf dependency - use HTML export with browser print for PDF")
}
